(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react')) :
	typeof define === 'function' && define.amd ? define(['react'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.client = factory(global.React));
})(this, (function (React) { 'use strict';

	function _interopNamespaceDefault(e) {
		var n = Object.create(null);
		if (e) {
			Object.keys(e).forEach(function (k) {
				if (k !== 'default') {
					var d = Object.getOwnPropertyDescriptor(e, k);
					Object.defineProperty(n, k, d.get ? d : {
						enumerable: true,
						get: function () { return e[k]; }
					});
				}
			});
		}
		n.default = e;
		return Object.freeze(n);
	}

	var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);

	const FunctionComponent = 0;
	const HostRoot = 3;
	// <div></div>
	const HostComponent = 5;
	// text
	const HostText = 6;

	const NoFlags = 0b0000000;
	const Placement = 0b0000001;
	const Update = 0b0000010;
	const ChildDelete = 0b0000100;
	const MutationMask = Placement | Update | ChildDelete;

	class FiberNode {
	    tag;
	    key;
	    stateNode;
	    type;
	    ref;
	    return;
	    sibling;
	    child;
	    index;
	    pendingProps;
	    memoizedProps;
	    memoizedState;
	    updateQueue;
	    deletions; // 需要删除的子fiber节点
	    alternate; // 交替,代替者
	    flags;
	    subtreeFlags;
	    constructor(tag, pendingProps, key) {
	        this.tag = tag;
	        this.key = key;
	        // HostComponent div Dom
	        // FunctionComponent () => {}
	        this.stateNode = null;
	        this.type = null;
	        /* 节点之间的关系属性,构成树级结构 */
	        // 父级节点
	        this.return = null;
	        // 同级右侧的兄弟节点
	        this.sibling = null;
	        this.child = null;
	        // 同级节点的位置数
	        this.index = 0;
	        this.ref = null;
	        /** 作为工作单元 */
	        // 工作单元开始工作的状态
	        this.pendingProps = pendingProps;
	        // 工作执行完确定下来的memoizedProps
	        this.memoizedProps = null;
	        this.memoizedState = null;
	        //
	        this.updateQueue = null;
	        // 交替单元,如果当前的FiberNode是current,那么alternate指向workProgress,如果当前FiberNode是workProgress,那么alternate指向current
	        this.alternate = null;
	        // 副作用
	        this.flags = NoFlags;
	        // 子树是否有副作用,在completeWork流程中，如果子树有副作用，冒泡到父级节点，方便查找副作用
	        this.subtreeFlags = NoFlags;
	        // 子树是否有需要删除的Fiber节点
	        this.deletions = null;
	    }
	}
	/***
	 *
	 *     * * * * * * * * *                 * * * * * * * * *               * * * * * * * * *
	 *     *               *   ---current--> *               *   ---child--> *               *
	 *     * FiberRootNode *                 * hostRootFiber *               *      APP      *
	 *     *               *   <-stateNode-- *               *   <--return-- *               *
	 *     * * * * * * * * *                 * * * * * * * * *               * * * * * * * * *
	 *
	 */
	/**
	 * ReactDom.createRoot(rootElement).render(<App />)
	 * rootElement对应的fiberNode为hostRootFiber
	 * fiberRootNode的current --> hostRootFiber
	 */
	class FiberRootNode {
	    // 挂载节点rootElement
	    container;
	    // 指向hostRootFiber
	    current;
	    // 这个更新流程(递归结束)的hostRootFiber保存在finishedWork中
	    finishedWork;
	    constructor(container, hostRootFiber) {
	        this.container = container;
	        this.current = hostRootFiber;
	        this.finishedWork = hostRootFiber;
	        hostRootFiber.stateNode = this;
	        this.finishedWork = null;
	    }
	}
	const createWorkInProgress = (current, pendingProps) => {
	    let wip = current.alternate;
	    if (wip === null) {
	        // mount
	        wip = new FiberNode(current.tag, pendingProps, current.key);
	        wip.stateNode = current.stateNode;
	        wip.alternate = current;
	        current.alternate = wip;
	    }
	    else {
	        // update
	        wip.pendingProps = pendingProps;
	        wip.flags = NoFlags;
	        wip.subtreeFlags = NoFlags;
	        wip.deletions = null;
	    }
	    wip.type = current.type;
	    wip.updateQueue = current.updateQueue;
	    wip.child = current.child;
	    wip.memoizedProps = current.memoizedProps;
	    return wip;
	};
	/**
	 * ReactElement 转化为 FiberNode
	 * @param element
	 * @returns
	 */
	function createFiberFromElement(element) {
	    const { type, key, props } = element;
	    let fiberTag = FunctionComponent;
	    if (typeof type === 'string') {
	        // div type: 'div'
	        fiberTag = HostComponent;
	    }
	    else if (typeof type !== 'function' && true) {
	        console.warn('未定义的type类型', element);
	    }
	    const fiber = new FiberNode(fiberTag, props, key);
	    fiber.type = type;
	    return fiber;
	}

	// 创建
	const createUpdate = (action) => {
	    return {
	        action,
	    };
	};
	// 插入
	const enqueueUpdate = (updateQueue, update) => {
	    updateQueue.shared.pending = update;
	};
	// 初始化
	const createUpdateQueue = () => {
	    const updateQueue = {
	        shared: {
	            pending: null,
	        },
	        dispatch: null
	    };
	    return updateQueue;
	};
	// 消费
	const processUpdateQueue = (baseState, pendingUpdate) => {
	    const result = {
	        memoizedState: baseState,
	    };
	    if (pendingUpdate !== null) {
	        const action = pendingUpdate.action;
	        if (action instanceof Function) {
	            // baseState 1 update(x) => 4x -> memoizedState 4
	            result.memoizedState = action(baseState);
	        }
	        else {
	            // baseState 1 update2 -> memoizedState2
	            result.memoizedState = action;
	        }
	    }
	    return result;
	};

	const supportSymbol = typeof Symbol === 'function' && Symbol.for;
	const REACT_ELEMENT_TYPE = supportSymbol
	    ? Symbol.for('react.element')
	    : 0xeac7;

	function ChildReconciler(shouldTrackEffects) {
	    function deleteChild(returnFiber, childToDelete) {
	        if (!shouldTrackEffects) {
	            return;
	        }
	        const deletions = returnFiber.deletions;
	        if (deletions === null) {
	            returnFiber.deletions = [childToDelete];
	            returnFiber.flags |= ChildDelete;
	        }
	        else {
	            deletions.push(childToDelete);
	        }
	    }
	    // HostComponent <div></div>
	    function reconcileSingleElement(returnFiber, currentFiber, element) {
	        const key = element.key;
	        work: if (currentFiber !== null) {
	            // update
	            if (currentFiber.key === key) {
	                // key相同
	                if (element.$$typeof === REACT_ELEMENT_TYPE) {
	                    if (currentFiber.type === element.type) {
	                        // type相同
	                        const existing = useFiber(currentFiber, element.props);
	                        existing.return = returnFiber;
	                        return existing;
	                    }
	                    // 删除旧的，key相同,type不相同
	                    deleteChild(returnFiber, currentFiber);
	                    break work;
	                }
	                else {
	                    {
	                        console.warn('还未实现的react类型', element);
	                        break work;
	                    }
	                }
	            }
	            else {
	                // 删掉旧的
	                deleteChild(returnFiber, currentFiber);
	            }
	        }
	        // 根据Element创建fiber
	        const fiber = createFiberFromElement(element);
	        fiber.return = returnFiber;
	        return fiber;
	    }
	    // HostText
	    function reconcileSingleTextNode(returnFiber, currentFiber, content) {
	        if (currentFiber !== null) {
	            // update
	            if (currentFiber.tag === HostText) {
	                // 类型没变，可以复用
	                const existing = useFiber(currentFiber, { content });
	                existing.return = returnFiber;
	                return existing;
	            }
	            deleteChild(returnFiber, currentFiber);
	        }
	        const fiber = new FiberNode(HostText, { content }, null);
	        fiber.return = returnFiber;
	        return fiber;
	    }
	    function placeSingleChild(fiber) {
	        if (shouldTrackEffects && fiber.alternate === null) {
	            // fiber.alternate 指向的current,current === null,说明当前的节点是刚创建的,是首屏渲染的过程
	            fiber.flags |= Placement;
	        }
	        return fiber;
	    }
	    return function reconcileFibers(returnFiber, currentFiber, newChild) {
	        // 判断当前的fiber的类型
	        if (typeof newChild === 'object') {
	            switch (newChild.$$typeof) {
	                case REACT_ELEMENT_TYPE:
	                    return placeSingleChild(reconcileSingleElement(returnFiber, currentFiber, newChild));
	                default:
	                    {
	                        console.warn('未实现的reconcile类型', newChild);
	                    }
	                    break;
	            }
	        }
	        // TODO 多节点的情况 ul > li*3
	        //HostText
	        if (typeof newChild === 'string' || typeof newChild === 'number') {
	            return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFiber, newChild));
	        }
	        if (currentFiber !== null) {
	            // 兜底删除
	            deleteChild(returnFiber, currentFiber);
	        }
	        {
	            console.warn('未实现的reconcile类型', newChild);
	        }
	        // return fiberNode
	    };
	}
	/**
	 * TOTHINK: 在首次mount创建的Fiber树中,alternate的值是什么
	 * 调用了useFiber的情况下，获取到的是current.alternate
	 * 在更新流程，重置一些属性返回即为clone的值
	 * 注意：``对于同一个fiberNode，即使反复更新，current、wip这两个fiberNode会重复利用``
	 */
	function useFiber(fiber, pendingProps) {
	    const clone = createWorkInProgress(fiber, pendingProps);
	    clone.index = 0;
	    clone.sibling = null;
	    return clone;
	}
	const reconcileChildFibers = ChildReconciler(true);
	const mountChildFibers = ChildReconciler(false);

	const internals = React__namespace.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRE;

	const { currentDispatcher } = internals;
	/**
	 * 当前在render的Fiber,当前函数组件在执行过程的记录
	 *
	 */
	let currentlyRenderingFiber = null;
	/**
	 * 当进入function Component的beginWork的时候，处理hook链表中的每个hook，需要有个指针来记录当前的hook
	 */
	let workInProgressHook = null;
	/**
	 * update流程当前的Hook
	 */
	let currentHook = null;
	function renderWithHooks(wip) {
	    // 赋值操作
	    currentlyRenderingFiber = wip;
	    // 重置，保存的是hooks链表,在mount流程的时候，是新创建；而update需要从
	    wip.memoizedState = null;
	    const current = wip.alternate;
	    if (current !== null) {
	        // update
	        currentDispatcher.current = HooksDispatcherOnUpdate;
	    }
	    else {
	        // mount
	        currentDispatcher.current = HooksDispatcherOnMount;
	    }
	    const Component = wip.type;
	    const props = wip.pendingProps;
	    const children = Component(props);
	    // 重置操作
	    currentlyRenderingFiber = null;
	    return children;
	}
	const HooksDispatcherOnMount = {
	    useState: mountState,
	};
	const HooksDispatcherOnUpdate = {
	    useState: updateState,
	};
	function updateState(initialState) {
	    const hook = updateWorkInProgressHook();
	    // 计算新的state的逻辑
	    const queue = hook.updateQueue;
	    const pending = queue.shared.pending;
	    if (pending !== null) {
	        const { memoizedState } = processUpdateQueue(hook.memoizedState, pending);
	        hook.memoizedState = memoizedState;
	    }
	    return [hook.memoizedState, queue.dispatch];
	}
	function updateWorkInProgressHook() {
	    // todo Render阶段触发的更新
	    // function App(){
	    //   const [num,setNum] = useState(0)
	    //   // 触发更新
	    //   setNum(100)
	    //   return <div>{num}</div>
	    // }
	    let nextCurrentHook = null;
	    if (currentHook === null) {
	        // 这是这个FC update时第一个hook
	        const current = currentlyRenderingFiber?.alternate;
	        if (current !== null) {
	            nextCurrentHook = current?.memoizedState;
	        }
	        else {
	            // mount mount阶段current===null,是一些边界情况
	            nextCurrentHook = null;
	        }
	    }
	    else {
	        // 这是FC update时后续的Hook
	        nextCurrentHook = currentHook.next;
	    }
	    if (nextCurrentHook === null) {
	        /**
	         * mount u1 u2 u3
	         * update u1 u2 u3 u4 --> 多一个hook
	         * 如果nextCurrentHook === null的情况，说明mount阶段和update阶段的hook数量一样
	         */
	        throw new Error(`组件${currentlyRenderingFiber?.type}本次执行时的Hook比上次执行的多`);
	    }
	    currentHook = nextCurrentHook;
	    const newHook = {
	        memoizedState: currentHook.memoizedState,
	        updateQueue: currentHook.updateQueue,
	        next: null,
	    };
	    if (workInProgressHook === null) {
	        if (currentlyRenderingFiber === null) {
	            throw new Error('请在函数组件内调用hook');
	        }
	        else {
	            workInProgressHook = newHook;
	            currentlyRenderingFiber.memoizedProps = workInProgressHook;
	        }
	    }
	    else {
	        // mount时，后续的hook
	        workInProgressHook.next = newHook;
	        workInProgressHook = newHook;
	    }
	    return workInProgressHook;
	}
	function mountState(initialState) {
	    // 找到当前userState对应的hook数据
	    const hook = mountWorkInProgressHook();
	    let memoizedState;
	    if (initialState instanceof Function) {
	        memoizedState = initialState();
	    }
	    else {
	        memoizedState = initialState;
	    }
	    const queue = createUpdateQueue();
	    hook.updateQueue = queue;
	    hook.memoizedState = memoizedState;
	    //@ts-ignore
	    // toThink 函数的bind方法，代入参数，此时是没有执行，只是将对应的实时参数赋予
	    const dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
	    queue.dispatch = dispatch;
	    return [memoizedState, dispatch];
	}
	function dispatchSetState(fiber, updateQueue, action) {
	    // toThink 首屏渲染的更新流程
	    // const update = createUpdate<ReactElementType | null>(element);
	    // 	enqueueUpdate(
	    // 		hostRootFiber.updateQueue as UpdateQueue<ReactElementType | null>,
	    // 		update,
	    // 	);
	    // 	scheduleUpdateOnFiber(hostRootFiber);
	    const update = createUpdate(action);
	    enqueueUpdate(updateQueue, update);
	    scheduleUpdateOnFiber(fiber);
	}
	function mountWorkInProgressHook() {
	    const hook = {
	        memoizedState: null,
	        updateQueue: null,
	        next: null,
	    };
	    if (workInProgressHook === null) {
	        // mount时，第一个hook
	        if (currentlyRenderingFiber === null) {
	            // 如果currentlyRenderingFiber等于null，则说明hook没有在function Component中使用，
	            // 当执行mountWorkInProgressHook的时候，currentlyRenderingFiber是会指向现在正在render的FiberNode
	            /**
	             * function App(){
	             *  useState(0)
	             * }
	             */
	            throw new Error('请在函数组件内调用hook');
	        }
	        else {
	            workInProgressHook = hook;
	            currentlyRenderingFiber.memoizedProps = workInProgressHook;
	        }
	    }
	    else {
	        // mount时，后续的hook
	        workInProgressHook.next = hook;
	        workInProgressHook = hook;
	    }
	    return workInProgressHook;
	}

	/**
	 * 递归中的递阶段
	 * <A>
	 *  <B/>
	 * </A>
	 * 当进入A的beginWork时，通过对比B current fiberNode 与 B reactElement,生成B对应的wip fiberNode
	 * 在此过程中最多会标记两类与"结构变化"相关的flags
	 * — Placement
	 *    插入： a --> ab 移动：abc --> bca
	 * — ChildDeletion
	 *    删除：ul>li*3 --> ul>li
	 * 不包含与"属性变化"相关的flag:
	 * Update
	 * <img title='1' /> --> <img title='2'/>
	 *
	 *
	 * —— HostRoot的beginWork工作流程：
	 *    1.计算状态的最新值
	 *    2.创造子fiberNode
	 *
	 * —— HostComponent的beginWork工作流程：
	 *    1.创造子fiberNode
	 *
	 * ——— HostText没有beginWork流程(因为没有其它子节点)
	 */
	function beginWork(wip) {
	    switch (wip.tag) {
	        case HostRoot:
	            return updateHostRoot(wip);
	        case HostComponent:
	            return updateHostComponent(wip);
	        case HostText:
	            return null;
	        case FunctionComponent:
	            return updateFunctionComponent(wip);
	        default:
	            {
	                console.warn('beginWork未实现的类型');
	            }
	            break;
	    }
	    return null;
	}
	function updateHostRoot(wip) {
	    const baseState = wip.memoizedState;
	    const updateQueue = wip.updateQueue;
	    const pending = updateQueue.shared.pending;
	    updateQueue.shared.pending = null;
	    const { memoizedState } = processUpdateQueue(baseState, pending);
	    // 执行到这里的时候wip.memoizedState = <App /> 从fiberReconciler中的updateContainer方法为起始点
	    wip.memoizedState = memoizedState;
	    const nextChildren = wip.memoizedState;
	    reconcilerChildren(wip, nextChildren);
	    return wip.child;
	}
	function updateHostComponent(wip) {
	    const nextProps = wip.pendingProps;
	    const nextChildren = nextProps.children;
	    reconcilerChildren(wip, nextChildren);
	    return wip.child;
	}
	function updateFunctionComponent(wip) {
	    // function App(){
	    //   return <img />
	    // }
	    const nextChildren = renderWithHooks(wip);
	    reconcilerChildren(wip, nextChildren);
	    return wip.child;
	}
	function reconcilerChildren(wip, children) {
	    // 对比子节点的current fiberNode 与 子节点的ReactElement,来生成wip fiberNode
	    const current = wip.alternate;
	    /**
	     * React.createDom(hostElement).render(<App/>)
	     * 在首屏渲染的时候，通过createWorkInProgress已经将hostElement对应的hostRootFiber初始化了
	     * alternate字段，所以下面的条件判断，hostFiber下的子节点只会进入mounted过程
	     */
	    if (current !== null) {
	        // update
	        wip.child = reconcileChildFibers(wip, current?.child, children);
	    }
	    else {
	        // mounted
	        /**
	         * 从父级节点向下遍历,依次将子ReactElement转换为FiberNode
	         */
	        // wip FiberNode
	        wip.child = mountChildFibers(wip, null, children);
	    }
	}

	const createInstance = (type) => {
	    return document.createElement(type);
	};
	const createTextInstance = (content) => {
	    return document.createTextNode(content);
	};
	const appendInitialChild = (parent, child) => {
	    parent.appendChild(child);
	};
	const appendChildToContainer = appendInitialChild;
	function commitUpdate(fiber) {
	    switch (fiber.tag) {
	        case HostText:
	            const text = fiber.memoizedProps.content;
	            return commitTextUpdate(fiber.stateNode, text);
	        default:
	            {
	                console.warn('未实现的Update类型', fiber);
	            }
	            break;
	    }
	}
	function commitTextUpdate(textInstance, content) {
	    textInstance.textContent = content;
	}
	function removeChild(child, container) {
	    container.removeChild(child);
	}

	/**
	 * commit 阶段要执行的任务
	 * 1.fiber树的切换
	 * 2.执行Placement对应操作
	 *
	 * 需要注意的问题，如果span含有flag,该如何找到它
	 * <App>
	 *   <div>
	 *    <span>内容</span>
	 *   </div>
	 * </App>
	 *
	 */
	let nextEffect = null;
	function commitMutationEffects(finishedWork) {
	    nextEffect = finishedWork;
	    while (nextEffect !== null) {
	        // 向下遍历
	        const child = nextEffect.child;
	        if ((nextEffect.subtreeFlags & MutationMask) !== NoFlags &&
	            child !== null) {
	            nextEffect = child;
	        }
	        else {
	            // 向上遍历,执行到没有subtreeFlags副作用的节点，即下面的节点没有变化，可以不用向下检测了
	            up: while (nextEffect !== null) {
	                // debugger;
	                commitMutationEffectsOnFiber(nextEffect);
	                const sibling = nextEffect.sibling;
	                if (sibling !== null) {
	                    nextEffect = sibling;
	                    break up;
	                }
	                nextEffect = nextEffect.return;
	            }
	        }
	    }
	}
	const commitMutationEffectsOnFiber = (finishedWork) => {
	    const flags = finishedWork.flags;
	    if ((flags & Placement) !== NoFlags) {
	        commitPlacement(finishedWork);
	        finishedWork.flags &= ~Placement;
	    }
	    // flags Update
	    if ((flags & Update) !== NoFlags) {
	        commitUpdate(finishedWork);
	        finishedWork.flags &= ~Update;
	    }
	    // flags Deletion
	    if ((flags & ChildDelete) !== NoFlags) {
	        const deletions = finishedWork.deletions;
	        if (deletions !== null) {
	            deletions.forEach((childToDelete) => {
	                commitDeletion(childToDelete);
	            });
	        }
	        commitUpdate(finishedWork);
	        finishedWork.flags &= ~ChildDelete;
	    }
	};
	function commitDeletion(childToDelete) {
	    let rootHostNode = null;
	    /**
	     * TOTHINK:难道不是子节点先unmount ??
	     * unmountFiber 流程是div --> p --> 12 -> p
	     * <div>
	     *  <App />
	     *  <p />
	     * </div>
	     *
	     * function App(){
	     *  return <p>12</p>
	     * }
	     */
	    // 递归子树
	    commitNestedComponent(childToDelete, (unmountFiber) => {
	        switch (unmountFiber.tag) {
	            case HostComponent:
	                if (rootHostNode === null) {
	                    rootHostNode = unmountFiber;
	                }
	                // TODO 解绑ref
	                return;
	            case HostText:
	                if (rootHostNode === null) {
	                    rootHostNode = unmountFiber;
	                }
	                return;
	            case FunctionComponent:
	                // TODO useEffect unmount
	                break;
	            default:
	                {
	                    console.warn('未处理的unmount类型', unmountFiber);
	                }
	        }
	    });
	    // 移除rootHostComponent的DOM
	    if (rootHostNode !== null) {
	        const hostParent = getHostParent(childToDelete);
	        if (hostParent !== null) {
	            removeChild(rootHostNode, hostParent);
	        }
	    }
	    childToDelete.return = null;
	    childToDelete.child = null;
	}
	function commitNestedComponent(root, onCommitUnMount) {
	    let node = root;
	    while (true) {
	        onCommitUnMount(node);
	        if (node.child !== null) {
	            // 向下遍历
	            node.child.return = node;
	            node = node.child;
	            continue;
	        }
	        if (node === root) {
	            // 终止条件
	            return;
	        }
	        while (node.sibling === null) {
	            if (node.return === null || node.return === root) {
	                return;
	            }
	            // 向上归
	            node = node.return;
	        }
	        node.sibling.return = node.return;
	        node = node.sibling;
	    }
	}
	const commitPlacement = (finishedWork) => {
	    // debugger;
	    {
	        console.warn('执行Placement操作', finishedWork);
	    }
	    // parent Dom 获取宿主环境的父级节点
	    const hostParent = getHostParent(finishedWork);
	    // finishedWork  DOM append parent DOM
	    if (hostParent !== null) {
	        appendPlacementNodeIntoContainer(finishedWork, hostParent);
	    }
	};
	const getHostParent = (fiber) => {
	    let parent = fiber.return;
	    while (parent) {
	        const parentTag = parent.tag;
	        // HostComponent HostRoot
	        if (parentTag === HostComponent) {
	            return parent.stateNode;
	        }
	        // HostRoot ---> FiberRootNode
	        if (parentTag === HostRoot) {
	            return parent.stateNode.container;
	        }
	        parent = parent.return;
	    }
	    {
	        console.warn('未找到host parent');
	    }
	    return null;
	};
	const appendPlacementNodeIntoContainer = (finishedWork, hostParent) => {
	    // fiber host 传进来的finishedWork的节点并不一定是原生节点，可以执行append操作,所以需要遍历找到HostComponent和HostText类型的finishedWork.tag
	    if (finishedWork.tag === HostComponent || finishedWork.tag === HostText) {
	        appendChildToContainer(hostParent, finishedWork.stateNode);
	        return;
	    }
	    const child = finishedWork.child;
	    if (child !== null) {
	        appendPlacementNodeIntoContainer(child, hostParent);
	        let sibling = child.sibling;
	        while (sibling !== null) {
	            appendPlacementNodeIntoContainer(sibling, hostParent);
	            sibling = sibling.sibling;
	        }
	    }
	};

	/** 递归中的归
	 *  completeWork
	 *  需要解决的问题
	 *  —— 对于Host类型fiberNode: 构建离屏DOM树
	 *  —— 标记Update Tag
	 *
	 *  completeWork性能优化策略
	 *  flags分布在不同fiberNode中,如何快速找到他们？
	 *  answer: 利用completeWork向上遍历的流程，将子fiberNode的flags冒泡到父fiberNode
	 *
	 */
	function markUpdate(fiber) {
	    fiber.flags |= Update;
	}
	const completeWork = (wip) => {
	    const newProps = wip.pendingProps;
	    const current = wip.alternate;
	    switch (wip.tag) {
	        case HostComponent:
	            if (current !== null && wip.stateNode) ;
	            else {
	                // mount
	                /*
	          1.构建DOM
	         */
	                // const instance = createInstance(wip.type, newProps);
	                const instance = createInstance(wip.type);
	                /**
	                 * 2.将DOM插入到DOM树中
	                 *  */
	                appendAllChildren(instance, wip);
	                wip.stateNode = instance;
	            }
	            bubbleProperties(wip);
	            return null;
	        case HostText:
	            if (current !== null && wip.stateNode) {
	                // update
	                const oldText = current.memoizedProps.content;
	                const newText = newProps.content;
	                if (oldText !== newText) {
	                    markUpdate(wip);
	                }
	            }
	            else {
	                // mount
	                /*
	          1.构建DOM
	          toThink 不需要执行append的操作？？？
	         */
	                const instance = createTextInstance(newProps.content);
	                wip.stateNode = instance;
	            }
	            bubbleProperties(wip);
	            return null;
	        case HostRoot:
	            bubbleProperties(wip);
	            return null;
	        case FunctionComponent:
	            bubbleProperties(wip);
	            return null;
	        default:
	            {
	                console.warn('未实现的completeWork情况', wip);
	            }
	            break;
	    }
	    return null;
	};
	/**
	 *
	 * @param parent
	 * @param wip
	 *
	 * 难点情况示例：
	 * 找到父级节点,A函数组件的父级元素节点是h3
	 * function A(){
	 * }
	 * const jsx = <h3><A/></h3>
	 *
	 * toThink: 流程理解
	 */
	function appendAllChildren(parent, wip) {
	    let node = wip.child;
	    while (node !== null) {
	        if (node.tag === HostComponent || node.tag === HostText) {
	            appendInitialChild(parent, node?.stateNode);
	        }
	        else if (node.child !== null) {
	            node.child.return = node;
	            node = node.child;
	            continue;
	        }
	        if (node === wip) {
	            return;
	        }
	        while (node.sibling === null) {
	            if (node.return === null || node.return === wip) {
	                return;
	            }
	            node = node?.return;
	        }
	        node.sibling.return = node.return;
	        node = node?.sibling;
	    }
	}
	function bubbleProperties(wip) {
	    let subtreeFlags = NoFlags;
	    let child = wip.child;
	    while (child !== null) {
	        subtreeFlags |= child.subtreeFlags;
	        subtreeFlags |= child.flags;
	        child.return = wip;
	        child = child.sibling;
	    }
	    wip.subtreeFlags |= subtreeFlags;
	}

	/**
	 * react内部有三个阶段
	 * 1.schedule阶段
	 * 2.render阶段(beginWork和completeWork)
	 * 3.commit阶段(commitWork) ----> beforeMutation mutation layout
	 */
	/***
	 *     * * * * * * * * *                 * * * * * * * * *               * * * * * * * * *
	 *     *               *   ---current--> *               *   ---child--> *               *
	 *     * FiberRootNode *                 * hostRootFiber *               *      APP      *
	 *     *               *   <-stateNode-- *               *   <--return-- *               *
	 *     * * * * * * * * *                 * * * * * * * * *               * * * * * * * * *
	 */
	// 全局当前执行的FiberNode
	let workInProgress = null;
	/**初始化首个执行的Fiber,即hostRootFiber*/
	function prepareFreshStack(root) {
	    workInProgress = createWorkInProgress(root.current, {});
	}
	// 调用主入口，挂载的初始化函数在fiberReconciler.ts
	function scheduleUpdateOnFiber(fiber) {
	    // TODO 调度功能
	    //fiberRootNode
	    const root = markUpdateFromFiberToRoot(fiber);
	    renderRoot(root);
	}
	/**
	 * 传入fiber节点获取FiberRootNode
	 * @param fiber
	 * @returns
	 */
	function markUpdateFromFiberToRoot(fiber) {
	    let node = fiber;
	    let parent = node.return;
	    while (parent !== null) {
	        node = parent;
	        parent = node.return;
	    }
	    if (node.tag === HostRoot) {
	        return node.stateNode;
	    }
	    return null;
	}
	// toThink 这里传入的root可以是最上层的节点，也可以是某个组件的节点？
	function renderRoot(root) {
	    // 初始化
	    prepareFreshStack(root);
	    do {
	        try {
	            workLoop();
	            break;
	        }
	        catch (error) {
	            {
	                console.warn('workLoop发生错误');
	            }
	            workInProgress = null;
	        }
	    } while (true);
	    const finishedWork = root.current.alternate;
	    root.finishedWork = finishedWork;
	    /** wip fiberNode 树，树中包含了flag标记 */
	    commitRoot(root);
	}
	function commitRoot(root) {
	    const finishedWork = root.finishedWork;
	    if (finishedWork === null) {
	        return;
	    }
	    {
	        console.warn('commit阶段开始', finishedWork);
	    }
	    // 重置操作
	    root.finishedWork = null;
	    // 判断是否存在3个子阶段需要执行的操作
	    // root flags root subtreeFlags
	    const subTreeHasEffect = (finishedWork.subtreeFlags & MutationMask) !== NoFlags;
	    const rootHasEffect = (finishedWork.flags & MutationMask) !== NoFlags;
	    if (subTreeHasEffect || rootHasEffect) {
	        /**
	         * commit阶段有三个子阶段
	         * 1.beforeMutation阶段
	         * 2.mutation阶段
	         * 3.layout阶段
	         */
	        // mutation
	        commitMutationEffects(finishedWork);
	        root.current = finishedWork;
	    }
	    else {
	        root.current = finishedWork;
	    }
	}
	function workLoop() {
	    while (workInProgress !== null) {
	        performUnitOfWork(workInProgress);
	    }
	}
	function performUnitOfWork(fiber) {
	    // next 可能是子fiber,也可能是null
	    const next = beginWork(fiber);
	    fiber.memoizedProps = fiber.pendingProps;
	    if (next === null) {
	        //说明没有子fiber,递归到最深层,开始向上回溯,执行completeWork流程
	        completeUnitOfWork(fiber);
	    }
	    else {
	        workInProgress = next;
	    }
	}
	function completeUnitOfWork(fiber) {
	    let node = fiber;
	    do {
	        completeWork(node);
	        const sibling = node.sibling;
	        if (sibling !== null) {
	            workInProgress = sibling;
	            return;
	        }
	        node = node.return;
	        // 这里执行到根节点就会将workLoop的流程打断，render阶段结束
	        workInProgress = node;
	    } while (node !== null);
	}

	// ReactDom.createRoot()
	function createContainer(container) {
	    // hostRootFiber
	    const hostRootFiber = new FiberNode(HostRoot, {}, null);
	    // fiberRootNode
	    const root = new FiberRootNode(container, hostRootFiber);
	    hostRootFiber.updateQueue = createUpdateQueue();
	    return root;
	}
	// render
	function updateContainer(element, root) {
	    const hostRootFiber = root.current;
	    // toThink: 这里传入的是element,即是<App />,理应来说,createUpdate传入的是Action
	    const update = createUpdate(element);
	    enqueueUpdate(hostRootFiber.updateQueue, update);
	    scheduleUpdateOnFiber(hostRootFiber);
	    return element;
	}

	function createRoot(container) {
	    const root = createContainer(container);
	    return {
	        render(element) {
	            return updateContainer(element, root);
	        },
	    };
	}

	var ReactDOM = /*#__PURE__*/Object.freeze({
		__proto__: null,
		createRoot: createRoot
	});

	return ReactDOM;

}));
