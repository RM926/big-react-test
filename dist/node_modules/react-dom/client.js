(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, (global.client = global.client || {}, global.client.js = factory()));
})(this, (function () { 'use strict';

	const FunctionComponent = 0;
	const HostRoot = 3;
	// <div></div>
	const HostComponent = 5;
	// text
	const HostText = 6;

	const NoFlags = 0b0000000;
	const Placement = 0b0000001;
	const Update = 0b0000010;
	const ChildDelete = 0b0000100;
	const MutationMask = Placement | Update | ChildDelete;

	class FiberNode {
	    tag;
	    key;
	    stateNode;
	    type;
	    ref;
	    return;
	    sibling;
	    child;
	    index;
	    pendingProps;
	    memoizedProps;
	    memoizedState;
	    updateQueue;
	    alternate; // 交替,代替者
	    flags;
	    subtreeFlags;
	    constructor(tag, pendingProps, key) {
	        this.tag = tag;
	        this.key = key;
	        // HostComponent div Dom
	        // FunctionComponent () => {}
	        this.stateNode = null;
	        this.type = null;
	        /* 节点之间的关系属性,构成树级结构 */
	        // 父级节点
	        this.return = null;
	        // 同级右侧的兄弟节点
	        this.sibling = null;
	        this.child = null;
	        // 同级节点的位置数
	        this.index = 0;
	        this.ref = null;
	        /** 作为工作单元 */
	        // 工作单元开始工作的状态
	        this.pendingProps = pendingProps;
	        // 工作执行完确定下来的memoizedProps
	        this.memoizedProps = null;
	        this.memoizedState = null;
	        //
	        this.updateQueue = null;
	        // 交替单元,如果当前的FiberNode是current,那么alternate指向workProgress,如果当前FiberNode是workProgress,那么alternate指向current
	        this.alternate = null;
	        // 副作用
	        this.flags = NoFlags;
	        // 子树是否有副作用,在completeWork流程中，如果子树有副作用，冒泡到父级节点，方便查找副作用
	        this.subtreeFlags = NoFlags;
	    }
	}
	/***
	 *
	 *     * * * * * * * * *                 * * * * * * * * *               * * * * * * * * *
	 *     *               *   ---current--> *               *   ---child--> *               *
	 *     * FiberRootNode *                 * hostRootFiber *               *      APP      *
	 *     *               *   <-stateNode-- *               *   <--return-- *               *
	 *     * * * * * * * * *                 * * * * * * * * *               * * * * * * * * *
	 *
	 */
	/**
	 * ReactDom.createRoot(rootElement).render(<App />)
	 * rootElement对应的fiberNode为hostRootFiber
	 * fiberRootNode的current --> hostRootFiber
	 */
	class FiberRootNode {
	    // 挂载节点rootElement
	    container;
	    // 指向hostRootFiber
	    current;
	    // 这个更新流程(递归结束)的hostRootFiber保存在finishedWork中
	    finishedWork;
	    constructor(container, hostRootFiber) {
	        this.container = container;
	        this.current = hostRootFiber;
	        this.finishedWork = hostRootFiber;
	        hostRootFiber.stateNode = this;
	        this.finishedWork = null;
	    }
	}
	const createWorkInProgress = (current, pendingProps) => {
	    let wip = current.alternate;
	    if (wip === null) {
	        // mount
	        wip = new FiberNode(current.tag, pendingProps, current.key);
	        wip.stateNode = current.stateNode;
	        wip.alternate = current;
	        current.alternate = wip;
	    }
	    else {
	        // update
	        wip.pendingProps = pendingProps;
	        wip.flags = NoFlags;
	        wip.subtreeFlags = NoFlags;
	    }
	    wip.type = current.type;
	    wip.updateQueue = current.updateQueue;
	    wip.child = current.child;
	    wip.memoizedProps = current.memoizedProps;
	    return wip;
	};
	/**
	 * ReactElement 转化为 FiberNode
	 * @param element
	 * @returns
	 */
	function createFiberFromElement(element) {
	    const { type, key, props } = element;
	    let fiberTag = FunctionComponent;
	    if (typeof type === 'string') {
	        // div type: 'div'
	        fiberTag = HostComponent;
	    }
	    else if (typeof type !== 'function' && true) {
	        console.warn('未定义的type类型', element);
	    }
	    const fiber = new FiberNode(fiberTag, props, key);
	    fiber.type = type;
	    return fiber;
	}

	// 创建
	const createUpdate = (action) => {
	    return {
	        action,
	    };
	};
	// 插入
	const enqueueUpdate = (updateQueue, update) => {
	    updateQueue.shared.pending = update;
	};
	// 初始化
	const createUpdateQueue = () => {
	    const updateQueue = {
	        shared: {
	            pending: null,
	        },
	    };
	    return updateQueue;
	};
	// 消费
	const processUpdateQueue = (baseState, pendingUpdate) => {
	    const result = {
	        memoizedState: baseState,
	    };
	    if (pendingUpdate !== null) {
	        const action = pendingUpdate.action;
	        if (action instanceof Function) {
	            // baseState 1 update(x) => 4x -> memoizedState 4
	            result.memoizedState = action(baseState);
	        }
	        else {
	            // baseState 1 update2 -> memoizedState2
	            result.memoizedState = action;
	        }
	    }
	    return result;
	};

	const supportSymbol = typeof Symbol === 'function' && Symbol.for;
	const REACT_ELEMENT_TYPE = supportSymbol
	    ? Symbol.for('react.element')
	    : 0xeac7;

	function ChildReconciler(shouldTrackEffects) {
	    // HostComponent <div></div>
	    function reconcileSingleElement(returnFiber, currentFiber, element) {
	        const fiber = createFiberFromElement(element);
	        fiber.return = returnFiber;
	        return fiber;
	    }
	    // HostText
	    function reconcileSingleTextNode(returnFiber, currentFiber, content) {
	        const fiber = new FiberNode(HostText, { content }, null);
	        fiber.return = returnFiber;
	        return fiber;
	    }
	    function placeSingleChild(fiber) {
	        if (shouldTrackEffects && fiber.alternate === null) {
	            // fiber.alternate 指向的current,current === null,说明当前的节点是刚创建的,是首屏渲染的过程
	            fiber.flags |= Placement;
	        }
	        return fiber;
	    }
	    return function reconcileFibers(returnFiber, currentFiber, newChild) {
	        // 判断当前的fiber的类型
	        if (typeof newChild === 'object') {
	            switch (newChild.$$typeof) {
	                case REACT_ELEMENT_TYPE:
	                    return placeSingleChild(reconcileSingleElement(returnFiber, currentFiber, newChild));
	                default:
	                    {
	                        console.warn('未实现的reconcile类型', newChild);
	                    }
	                    break;
	            }
	        }
	        //HostText
	        if (typeof newChild === 'string' || typeof newChild === 'number') {
	            return reconcileSingleTextNode(returnFiber, currentFiber, newChild);
	        }
	        // return fiberNode
	    };
	}
	const reconcileChildFibers = ChildReconciler(true);
	const mountChildFibers = ChildReconciler(false);

	function renderWithHooks(wip) {
	    const Component = wip.type;
	    const props = wip.pendingProps;
	    const children = Component(props);
	    return children;
	}

	/**
	 * 递归中的递阶段
	 * <A>
	 *  <B/>
	 * </A>
	 * 当进入A的beginWork时，通过对比B current fiberNode 与 B reactElement,生成B对应的wip fiberNode
	 * 在此过程中最多会标记两类与"结构变化"相关的flags
	 * — Placement
	 *    插入： a --> ab 移动：abc --> bca
	 * — ChildDeletion
	 *    删除：ul>li*3 --> ul>li
	 * 不包含与"属性变化"相关的flag:
	 * Update
	 * <img title='1' /> --> <img title='2'/>
	 *
	 *
	 * —— HostRoot的beginWork工作流程：
	 *    1.计算状态的最新值
	 *    2.创造子fiberNode
	 *
	 * —— HostComponent的beginWork工作流程：
	 *    1.创造子fiberNode
	 *
	 * ——— HostText没有beginWork流程(因为没有其它子节点)
	 */
	function beginWork(wip) {
	    switch (wip.tag) {
	        case HostRoot:
	            return updateHostRoot(wip);
	        case HostComponent:
	            return updateHostComponent(wip);
	        case HostText:
	            return null;
	        case FunctionComponent:
	            return updateFunctionComponent(wip);
	        default:
	            {
	                console.warn('beginWork未实现的类型');
	            }
	            break;
	    }
	    return null;
	}
	function updateHostRoot(wip) {
	    const baseState = wip.memoizedState;
	    const updateQueue = wip.updateQueue;
	    const pending = updateQueue.shared.pending;
	    updateQueue.shared.pending = null;
	    const { memoizedState } = processUpdateQueue(baseState, pending);
	    // 执行到这里的时候wip.memoizedState = <App /> 从fiberReconciler中的updateContainer方法为起始点
	    wip.memoizedState = memoizedState;
	    const nextChildren = wip.memoizedState;
	    reconcilerChildren(wip, nextChildren);
	    return wip.child;
	}
	function updateHostComponent(wip) {
	    const nextProps = wip.pendingProps;
	    const nextChildren = nextProps.children;
	    reconcilerChildren(wip, nextChildren);
	    return wip.child;
	}
	function updateFunctionComponent(wip) {
	    // function App(){
	    //   return <img />
	    // }
	    const nextChildren = renderWithHooks(wip);
	    reconcilerChildren(wip, nextChildren);
	    return wip.child;
	}
	function reconcilerChildren(wip, children) {
	    // 对比子节点的current fiberNode 与 子节点的ReactElement,来生成wip fiberNode
	    const current = wip.alternate;
	    /**
	     * React.createDom(hostElement).render(<App/>)
	     * 在首屏渲染的时候，通过createWorkInProgress已经将hostElement对应的hostRootFiber初始化了
	     * alternate字段，所以下面的条件判断，hostFiber下的子节点只会进入mounted过程
	     */
	    if (current !== null) {
	        // update
	        wip.child = reconcileChildFibers(wip, current?.child, children);
	    }
	    else {
	        // mounted
	        /**
	         * 从父级节点向下遍历,依次将子ReactElement转换为FiberNode
	         */
	        // wip FiberNode
	        wip.child = mountChildFibers(wip, null, children);
	    }
	}

	const createInstance = (type) => {
	    return document.createElement(type);
	};
	const createTextInstance = (content) => {
	    return document.createTextNode(content);
	};
	const appendInitialChild = (parent, child) => {
	    parent.appendChild(child);
	};
	const appendChildToContainer = appendInitialChild;

	/**
	 * commit 阶段要执行的任务
	 * 1.fiber树的切换
	 * 2.执行Placement对应操作
	 *
	 * 需要注意的问题，如果span含有flag,该如何找到它
	 * <App>
	 *   <div>
	 *    <span>内容</span>
	 *   </div>
	 * </App>
	 *
	 */
	let nextEffect = null;
	function commitMutationEffects(finishedWork) {
	    nextEffect = finishedWork;
	    while (nextEffect !== null) {
	        // 向下遍历
	        const child = nextEffect.child;
	        if ((nextEffect.subtreeFlags & MutationMask) !== NoFlags &&
	            child !== null) {
	            nextEffect = child;
	        }
	        else {
	            // 向上遍历,执行到没有subtreeFlags副作用的节点，即下面的节点没有变化，可以不用向下检测了
	            up: while (nextEffect !== null) {
	                debugger;
	                commitMutationEffectsOnFiber(nextEffect);
	                const sibling = nextEffect.sibling;
	                if (sibling !== null) {
	                    nextEffect = sibling;
	                    break up;
	                }
	                nextEffect = nextEffect.return;
	            }
	        }
	    }
	}
	const commitMutationEffectsOnFiber = (finishedWork) => {
	    const flags = finishedWork.flags;
	    if ((flags & Placement) !== NoFlags) {
	        commitPlacement(finishedWork);
	        finishedWork.flags &= ~Placement;
	    }
	    // flags Update
	    // flags Deletion
	};
	const commitPlacement = (finishedWork) => {
	    debugger;
	    {
	        console.warn('执行Placement操作', finishedWork);
	    }
	    // parent Dom 获取宿主环境的父级节点
	    const hostParent = getHostParent(finishedWork);
	    // finishedWork  DOM append parent DOM 
	    if (hostParent !== null) {
	        appendPlacementNodeIntoContainer(finishedWork, hostParent);
	    }
	};
	const getHostParent = (fiber) => {
	    let parent = fiber.return;
	    while (parent) {
	        const parentTag = parent.tag;
	        // HostComponent HostRoot
	        if (parentTag === HostComponent) {
	            return parent.stateNode;
	        }
	        // HostRoot ---> FiberRootNode
	        if (parentTag === HostRoot) {
	            return parent.stateNode.container;
	        }
	        parent = parent.return;
	    }
	    {
	        console.warn('未找到host parent');
	    }
	    return null;
	};
	const appendPlacementNodeIntoContainer = (finishedWork, hostParent) => {
	    // fiber host 传进来的finishedWork的节点并不一定是原生节点，可以执行append操作,所以需要遍历找到HostComponent和HostText类型的finishedWork.tag
	    if (finishedWork.tag === HostComponent || finishedWork.tag === HostText) {
	        appendChildToContainer(hostParent, finishedWork.stateNode);
	        return;
	    }
	    const child = finishedWork.child;
	    if (child !== null) {
	        appendPlacementNodeIntoContainer(child, hostParent);
	        let sibling = child.sibling;
	        while (sibling !== null) {
	            appendPlacementNodeIntoContainer(sibling, hostParent);
	            sibling = sibling.sibling;
	        }
	    }
	};

	/** 递归中的归
	 *  completeWork
	 *  需要解决的问题
	 *  —— 对于Host类型fiberNode: 构建离屏DOM树
	 *  —— 标记Update Tag
	 *
	 *  completeWork性能优化策略
	 *  flags分布在不同fiberNode中,如何快速找到他们？
	 *  answer: 利用completeWork向上遍历的流程，将子fiberNode的flags冒泡到父fiberNode
	 *
	 */
	const completeWork = (wip) => {
	    const newProps = wip.pendingProps;
	    const current = wip.alternate;
	    switch (wip.tag) {
	        case HostComponent:
	            if (current !== null && wip.stateNode) ;
	            else {
	                // mount
	                /*
	          1.构建DOM
	         */
	                // const instance = createInstance(wip.type, newProps);
	                const instance = createInstance(wip.type);
	                /**
	                 * 2.将DOM插入到DOM树中
	                 *  */
	                appendAllChildren(instance, wip);
	                wip.stateNode = instance;
	            }
	            bubbleProperties(wip);
	            return null;
	        case HostText:
	            if (current !== null && wip.stateNode) ;
	            else {
	                // mount
	                /*
	          1.构建DOM
	          toThink 不需要执行append的操作？？？
	         */
	                const instance = createTextInstance(newProps.content);
	                wip.stateNode = instance;
	            }
	            bubbleProperties(wip);
	            return null;
	        case HostRoot:
	            bubbleProperties(wip);
	            return null;
	        case FunctionComponent:
	            bubbleProperties(wip);
	            return null;
	        default:
	            {
	                console.warn('未实现的completeWork情况', wip);
	            }
	            break;
	    }
	    return null;
	};
	/**
	 *
	 * @param parent
	 * @param wip
	 *
	 * 难点情况示例：
	 * 找到父级节点,A函数组件的父级元素节点是h3
	 * function A(){
	 * }
	 * const jsx = <h3><A/></h3>
	 *
	 * toThink: 流程理解
	 */
	function appendAllChildren(parent, wip) {
	    let node = wip.child;
	    while (node !== null) {
	        if (node.tag === HostComponent || node.tag === HostText) {
	            appendInitialChild(parent, node?.stateNode);
	        }
	        else if (node.child !== null) {
	            node.child.return = node;
	            node = node.child;
	            continue;
	        }
	        if (node === wip) {
	            return;
	        }
	        while (node.sibling === null) {
	            if (node.return === null || node.return === wip) {
	                return;
	            }
	            node = node?.return;
	        }
	        node.sibling.return = node.return;
	        node = node?.sibling;
	    }
	}
	function bubbleProperties(wip) {
	    let subtreeFlags = NoFlags;
	    let child = wip.child;
	    while (child !== null) {
	        subtreeFlags |= child.subtreeFlags;
	        subtreeFlags |= child.flags;
	        child.return = wip;
	        child = child.sibling;
	    }
	    wip.subtreeFlags |= subtreeFlags;
	}

	/**
	 * react内部有三个阶段
	 * 1.schedule阶段
	 * 2.render阶段(beginWork和completeWork)
	 * 3.commit阶段(commitWork) ----> beforeMutation mutation layout
	 */
	/***
	 *     * * * * * * * * *                 * * * * * * * * *               * * * * * * * * *
	 *     *               *   ---current--> *               *   ---child--> *               *
	 *     * FiberRootNode *                 * hostRootFiber *               *      APP      *
	 *     *               *   <-stateNode-- *               *   <--return-- *               *
	 *     * * * * * * * * *                 * * * * * * * * *               * * * * * * * * *
	 */
	// 全局当前执行的FiberNode
	let workInProgress = null;
	/**初始化首个执行的Fiber,即hostRootFiber*/
	function prepareFreshStack(root) {
	    workInProgress = createWorkInProgress(root.current, {});
	}
	// 调用主入口，挂载的初始化函数在fiberReconciler.ts
	function scheduleUpdateOnFiber(fiber) {
	    // TODO 调度功能
	    //fiberRootNode
	    const root = markUpdateFromFiberToRoot(fiber);
	    renderRoot(root);
	}
	/**
	 * 传入fiber节点获取FiberRootNode
	 * @param fiber
	 * @returns
	 */
	function markUpdateFromFiberToRoot(fiber) {
	    let node = fiber;
	    let parent = node.return;
	    while (parent !== null) {
	        node = parent;
	        parent = node.return;
	    }
	    if (node.tag === HostRoot) {
	        return node.stateNode;
	    }
	    return null;
	}
	// toThink 这里传入的root可以是最上层的节点，也可以是某个组件的节点？
	function renderRoot(root) {
	    // 初始化
	    prepareFreshStack(root);
	    do {
	        try {
	            workLoop();
	            break;
	        }
	        catch (error) {
	            {
	                console.warn('workLoop发生错误');
	            }
	            workInProgress = null;
	        }
	    } while (true);
	    const finishedWork = root.current.alternate;
	    root.finishedWork = finishedWork;
	    debugger;
	    /** wip fiberNode 树，树中包含了flag标记 */
	    commitRoot(root);
	}
	function commitRoot(root) {
	    const finishedWork = root.finishedWork;
	    if (finishedWork === null) {
	        return;
	    }
	    {
	        console.warn('commit阶段开始', finishedWork);
	    }
	    // 重置操作
	    root.finishedWork = null;
	    // 判断是否存在3个子阶段需要执行的操作
	    // root flags root subtreeFlags
	    const subTreeHasEffect = (finishedWork.subtreeFlags & MutationMask) !== NoFlags;
	    const rootHasEffect = (finishedWork.flags & MutationMask) !== NoFlags;
	    if (subTreeHasEffect || rootHasEffect) {
	        /**
	         * commit阶段有三个子阶段
	         * 1.beforeMutation阶段
	         * 2.mutation阶段
	         * 3.layout阶段
	         */
	        // mutation
	        commitMutationEffects(finishedWork);
	        root.current = finishedWork;
	    }
	    else {
	        root.current = finishedWork;
	    }
	}
	function workLoop() {
	    while (workInProgress !== null) {
	        performUnitOfWork(workInProgress);
	    }
	}
	function performUnitOfWork(fiber) {
	    // next 可能是子fiber,也可能是null
	    const next = beginWork(fiber);
	    fiber.memoizedProps = fiber.pendingProps;
	    if (next === null) {
	        //说明没有子fiber,递归到最深层,开始向上回溯,执行completeWork流程
	        debugger;
	        completeUnitOfWork(fiber);
	    }
	    else {
	        workInProgress = next;
	    }
	}
	function completeUnitOfWork(fiber) {
	    let node = fiber;
	    do {
	        completeWork(node);
	        const sibling = node.sibling;
	        if (sibling !== null) {
	            workInProgress = sibling;
	            return;
	        }
	        node = node.return;
	        // 这里执行到根节点就会将workLoop的流程打断，render阶段结束
	        workInProgress = node;
	    } while (node !== null);
	}

	// ReactDom.createRoot()
	function createContainer(container) {
	    // hostRootFiber
	    const hostRootFiber = new FiberNode(HostRoot, {}, null);
	    // fiberRootNode
	    const root = new FiberRootNode(container, hostRootFiber);
	    hostRootFiber.updateQueue = createUpdateQueue();
	    return root;
	}
	// render
	function updateContainer(element, root) {
	    const hostRootFiber = root.current;
	    // toThink: 这里传入的是element,即是<App />,理应来说,createUpdate传入的是Action
	    const update = createUpdate(element);
	    enqueueUpdate(hostRootFiber.updateQueue, update);
	    scheduleUpdateOnFiber(hostRootFiber);
	    return element;
	}

	function createRoot(container) {
	    const root = createContainer(container);
	    return {
	        render(element) {
	            updateContainer(element, root);
	        },
	    };
	}

	var ReactDOM = /*#__PURE__*/Object.freeze({
		__proto__: null,
		createRoot: createRoot
	});

	return ReactDOM;

}));
